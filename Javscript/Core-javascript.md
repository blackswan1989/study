<br>

출처: 코어자바스크립트

<br>

# 01. 데이터 타입

<br>
<br>

## 1. 데이터 타입의 종류

<br>

자바스크립트 데이터 타입에는 크게 두가지가 있는데 기본형(원시형: primitive type)과 참조형(reference type)이다. 기본형에는 number, string, boolean, null 등이 있고  ES6에서는 Symbol이 추가되었다. 

참조형으로는 객체(object)에 속하는 Array, function, Date, 정규표현식(RegExp) 등과, ES6에 추가된 Map, WeakMap, Set, WakSet 등이 객체의 하위 분류에 속한다.

<br>

<img src="https://user-images.githubusercontent.com/67410919/122848027-b782bc00-d343-11eb-9811-5548b276018f.png" width="50%">

<br>

기본형과 참조형을 구분하는 기준은 일반적으로 기본형은 할당이나 연산시 복제가 되고, 참조형은 참조가 된다고 알려져 있다. 엄밀히 말하면 둘 다 복제를 하긴 한다. 다만 기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다르다.

기본형은 불변성(immutability)을 띈다. 이 불면성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고 나아가 '식별자'와 '변수'의 개념을 구분할 수 있어야 한다. 메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 살펴보자.

<br>
<br>
<br>

## 2. 데이터 타입에 관한 배경 지식

<br>

### 2.1 메모리와 데이터

<br>

컴퓨터에서 0 또는 1 로만 표현할 수 있는 하나의 메모리 조각을 비트(bit)라고 한다. 메모리는 매우 많은 비트들로 구성되어 있는데, 각 비트는 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있다. 

비트 단위로 위치를 확인하는 것은 매우 비효율적이므로 몇 개씩 묶어 하나의 단위로 여긴다면 표현할 수 있는 값도 늘어나 동시에 검색 시간을 줄일 수도 있게 된다. 한편 많은 비트를 한 단위로 묶으면 낭비되는 비트가 생기기도 한다. 자주 사용하지 않을 데이터를  표현하기 위해 빈 공간을 남겨놓기 보다는, 문제가 되지 않을 적정한 공간을 묶는 편이 낫다.

그런 고민의 결과로 바이트(byte) 단위가 생겨났는데, 1바이트는 8개의 비트로 구성되어 있다. 1비트마다 0 또는 1의 두 가지 값을 표현할 수 있으므로 1바이트는 총 256(2의 8승)값을 표현할 수 있다. 2바이트는 16개의 비트이므로 65536(2의 16승)개의 값을 표현할 수 있다.

이러한 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다. 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있다.

<br>
<br>

### 2.2 식별자와 변수

<br>

식별자라고 해야 할 곳에 변수를, 변수라고 해야 할 곳에 식별자를 쓰는 식으로 변수와 식별자를 혼용하는 경우가 많다. 문맥에 따라 무엇을 말하고자 하는지 유추할 수 있기 때문인데, 둘의 차이를 모르면 혼란스러울 수 있다.

먼저 변수(variable)는 '변할 수 있는 수'로 수학 용어를 차용하여 숫자를 의미하는 '수'가 붙었을 뿐 값이 반듯이 숫자여야 하는것은 아니다. 영단어 variable은 원래 '변할 수 있다'라는 형용사이지만 컴퓨터 용어로 쓸 때에는 '변할 수 있는 무언가'라는 명사로 확장시켰다. 

여기서 '무언가'란 데이터를 뜻한다. 숫자도 데이터이고 문자열, 객체, 배열 모두 데이터이다. 식별자(identifier)는 어떤 데이터를 식별하는 데  사용하는 이름으로 즉 '변수명'이다.

<br>
<br>
<br>

## 3. 변수 선언과 데이터 할당

<br>

### 3.1 변수 선언

<br>

변수 선언의 동작 원리를 알아보자. 먼저 `var a;` 와 같은 기본적인 변수 선언식을 예로 들어 말로 풀어 쓰면 "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"가 된다. 

이렇게 보면 결국 변수란 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**이라고 할 수 있다. 이 공간에 숫자를 담았다가 문자열을 담는 등의 다양한 명령을 내릴 수 있다.

위에서 선언한 `var a;` 변수에 대한 메모리 영역의 변화를 살펴보면, 명령을 받은 컴퓨터는 메모리에 비어있는 공간 하나를 확보(`@1003` 주소값 확보)하고 이 공간의 이름(식별자)을 `a`라고 지정한다. 여기까지 변수의 선언 과정이다.

이후에 사용자가 `a`에 접근하고자 하면 컴퓨터는 메모리에서 `a`라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환하게 된다.

<br>
<br>

### 3.2 데이터 할당

<br>

```
var a;          // 변수 a 선언
a = 'abc';      // 변수 a에 데이터 할당

var a = 'abc';	// 변수 선언과 할당을 한 문장으로 표현
```

<br>

변수 할당 과정으로는 `a`라는 이름을 가진 주소를 검색해서 그곳에 문자열 `'abc'`를 할당한다고 해보자, 실제로는 메모리에서 `a`가 들어가있는 주소값의 위치에 문자열 `'abc'`를 직접 저장하지는 않는다.

<img src="https://user-images.githubusercontent.com/67410919/123027127-46610880-d418-11eb-8ff3-677af63fb1a1.png" width="70%">

<br>

데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해 `'abc'`를 저장하고 그 주소를 변수 영역에 저장하는 식으로 이루어진다. 그리고 데이터의 성질에 따라 '변수 영역', '데이터 영역'으로 구분된다.

<br>

#### # 데이터 할당의 전체 흐름

1. 변수 영역에서 빈공간(`@1003`) 확보
2. 확보한 공간의 식별자를 `a`로 지정
3. 데이터 영역의 빈 공간(`@5004`)에 문자열 `'abc'` 저장
4. 앞서 저장한 문자열 주소(`@5004`)를 `@1003`의 공간에 대입
  
<br>

변수 영역에 값을 직접 대입하지 않고 한 단계를 더 거치는 이유는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위함이다. 

숫자형 데이터는 61비트의 공간을 확보하지만 문자열은 정해진 규격없이 한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이기 때문이다.

만약 미리 확보한 공간 내에서만 데이터 변환을 한다면 데이터를 다시 저장할 때 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 선행되어야 한다. 이런 경우 중간에 있던 데이터를 늘려야 한다면 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고 이동시킨 주소를 각 식별자에 다시 연결하는 작업이 필요해져 컴퓨터가 처리해야 할 연산이 많아질 수 밖에 없다. 

<img src="https://user-images.githubusercontent.com/67410919/123025614-d18ccf00-d415-11eb-8636-d50be68ac54e.png" width="70%">

<br>

결국 효율적으로 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이라고 할 수 있다. 문자열 `'abc'`의 마지막에 `'def'`를 추가하려고 하면 컴퓨터는 `'abc'`가 저장된 공간에 `'abcdef'`를 추가하는 대신 `'abcdef'`라는 문자열을 **새롭게** 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결시키는 방법으로 처리한다.

<br>
<br>
<br>

## 4. 기본형 데이터와 참조형 데이터

<br>

### 4.1 불변값

<br>

변수(variable)와 상수(constant)를 구분하는 성질은 '변경 가능성'인데 이 변경 가능성의 대상은 **변수 영역**의 메모리이다. 데이터 할당이 한 번 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다. 반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.

기본형 데이터인 숫자, 문자열, boolean, null 등은 모두 불변값이다. 예를 통해 개념을 알아보자

```
var a = 'abc';
a = a + 'def';
```

변수 `a`에 문자열 `'abc'`를 할당했다가 뒤에 `'edf'`를 추가하면 새로운 문자열 `'abcedf'`를 만들어 그 주소를 변수 `a`에 저장하게 된다. 즉 `'abc'`와 `'abcedf'`는 완전히 별개의 데이터이다.

<br>

```
var b = 5;
var c = 5;
b = 7
```

여기서도 변수 `'b'`에 숫자 5를 할당하면 컴퓨터는 일단 데이터 영역에서 5를 찾고 없으면 그 때 데이터 공간을 하나 만들어 저장하고 그 주소를 `'b'`에 저장한다. 

그리고 변수 `'c'`를 선언하며 다시 같은 수인 숫자 5를 할당하려고 하는데, 이 때 컴퓨터는 데이터 영역에서 5를 찾는다. 변수 `'b'`에서 이미 만들어 놓은 값이 있으므로 그 주소를 재활용한다. 

마지막 줄에서 변수 `'b'`의 값을 7로 바꾸고자 하는데, 이 때 기존에 저장된 숫자 5를 7로 바꾸는 것이 아닌 기존에 저장했던 7을 찾아서 있으면 재활용하고 없으면 새로 만들어 `'b'`에 저장하는 것이다. 결국 모두 다른 값으로 변경되지 않는다.

이처럼 문자열이나 숫자 등은 한 번 만든 값을 다른 값으로 변경할 수 없다. 변경은 새로 만드는 동작을 통해서만 이루어진다. 이러한 성질이 바로 불변값이다. 한 번 만들어진 값은 가비지 컬렉터(garbage collector)로 부터 수거되지 않는 한 영원히 변하지 않는다.

<br>
<br>

### 4.2 가변값

<br>

위에서 기본형 데이터는 모두 불변값이다. 그렇다면 참조형 데이터는 모두 가변값일까? 기본적으로 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다. 참조형 데이터를 변수에 할당하는 과정 부터 확인해보자.

<br>

```
var obj1 = {
	a: 1,
	b: 'bbb'
};
```

<br>

<img src="https://user-images.githubusercontent.com/67410919/123194746-f64e7880-d4e1-11eb-9239-91588193063c.png" width="70%">

<br>

1. 컴퓨터는 변수 영역의 빈 공간인 `@1002`를 확보하고 그 주소의 이름을 `obj1`로 지정한다.
2. 임의의 데이터 저장 공간인 `@5001`에 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(`@7103~?`)를 `@5001`에 저장한다.
3. `@7103` 및 `@7104`에 각각 `a`와 `b`라는 프로퍼티 이름을 지정한다.
4. 데이터 영역에서 숫자 1을 검색하여 결과가 없으면 임의로 `@5003`에 저장하고 이 주소를 `@7103`에 저장한다.
5. 문자열 `'bbb'`역시 임의로 `@5004`에 저장하고 이 주소를 `@7104`에 저장한다.

<br>

이처럼 참조형 데이터에는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다느 점이다. 그림을 보면 객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용한다. 따라서 데이터 영역에 저장된 값은 모두 불변값이다.

그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 바로 이 부분 때문에 참조형 데이터는 가변값이라고 하는 것이다. 이 부분을 살펴보기 위해 추가로 `obj1.a = 2;`를 할당하려 한다고 가정해보자.

<br>

<img src="https://user-images.githubusercontent.com/67410919/123196572-20ee0080-d4e5-11eb-9909-171c04921389.png" width="70%">

<br>

`obj1`의 `a`프로퍼티에 숫자 2를 할당하려고 한다. 검색 결과가 없으므로 빈 공간인 `@5005`에 저장하고 이 주소를 `@7103`에 저장한다. 

`obj1.a = 2;`를 할당하기 위한 명령 전과 후에 변수 `obj1`이 바라보고 있는 주소는 `@5001`로 변하지 않는다. 즉 새로운 객체가 만들어 진 것이 아닌 기존의 객체 내부의 값만 바뀐 것이다.

<br>
<br>

#### # 중첩 객체

<br>

이번에는 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우를 일컫는 '중첩 객체(nested object)'를 살펴보자.

<br>

```
var obj = {
	x: 3,
	arr: [ 3, 4, 5 ]
};
```

<br>

<img src="https://user-images.githubusercontent.com/74888197/124407474-f6baff00-dd7e-11eb-837f-420705931b43.png" width="70%">

1. 컴퓨터는 변수 영역의 빈 공간인 `@1002`확보 후 그 주소의 이름을 obj로 지정.
2. 임의의 데이터 저장공간인 `@5001`에 데이터를 저장. 이 데이터는 여러 개의 변수와 값들을 모아놓은 그룹(객체)로 이 그룹의 각 변수들을 저장하기 위해 별도의 변수영역을 마련(`@7103~?`)하고 그 영역의 주소를 `@5001`에 저장한다.
3. `@7103`에 이름 `x`를, `@7104`에 이름 `arr`를 지정
4. 데이터 영역에서 숫자 `3`을 검색 후 없으므로 임의로 `@5002`에 저장하고, 이 주소를 `@7103`에 저장한다.
5. `@7104`에 저장할 값은 배열로서 데이터 그룹이며, 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수영역인 `@8104~?`를 마련하고, 그 영역의 주소정보(`@8104~?`)를 `@5003`에 저장 한 다음 `@5003`을 `@7104`에 저장한다.
6. 배열의 요소가 총 3개이므로 3개의 변수 공간을 확보하고 각각 인덱스(0, 1, 2)를 부여한다.
7. 데이터 영역에서 숫자 3을 검색 후 그 주소인 `@5002`를 `@8104`에 저장한다.
8. 데이터 영역에 숫자 4가 없으므로 `@5004`에 저장하고 그 주소를 `@8105`에 저장한다.
9. 데이터 영역에 숫자 4도 없으므로 `@5005`에 저장하고 그 주소를 `@8106`에 저장해준다.

<br>

> obj.arr[1]을 검색하면 메모리는 다음과 같은 검색 과정을 거치게 된다.
> 
> `@1002` > `@5001` > `@7103~?` > `@7104` > `@5003` > `@8104~?` > `@8105` > `@5004` > `4` 반환

<br>
<br>

#### # 중첩된 객체의 프로퍼티 재할당

<br>

위 상태에서 다음과 같이 재할당 명령(`obj.arr = 'str';`)을 내리면 어떻게 될까?

```
var obj = {
	x: 3,
	arr: [ 3, 4, 5 ]
};

obj.arr = 'str';
```

<br>

<img src="https://user-images.githubusercontent.com/67410919/124527635-08fd7180-de41-11eb-8f69-1c1909063356.png" width="70%">

<br>

`@5006`에 문자열 `str`을 저장하고, 그 주소를 `@7104`에 저장한다. 그럼 `@5003`은 더이상 자신의 주소를 참조하는 변수가 하나도 없게 된다.

어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 하는데, `@5003`의 참조 카운트는 `@7104`에 `@5003`이 저장돼 있던 시점까지는 `1`이었다가 `@7104`에 `@5003`이 저장되는 순간 `0`이 된다. 

이처럼 참조 카운트가 `0`인 메모리 주소(`@5003`)는 가비지 컬렉터(GC)의 수거 대상이 되고, 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다. 그리고 연쇄적으로 `@8104~?`의 각 데이터들의 참조 카운트도 `0`이 되고 이들 역시 CG수거 대상이 되어 사라지게 된다.

<br>
<br>

### 4.3 변수 복사 비교

<br>

동작 방식을 알았으니 이제 본격적으로 기본형 데이터와 참조형 데이터의 차이를 확인해보자. 먼저 변수를 복사할 때의 변화를 살펴보자.

<br>

```
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
```

<br>

<img src="https://user-images.githubusercontent.com/67410919/124529276-26343f00-de45-11eb-8f2d-5a854b46883a.png" width="70%">

<br>

1. 우선 기본형 데이터는 `@1001`을 확보하고 식별자를 `a`로 지정한다. 숫자 `10`을 데이터 영역에서 검사하고 없으므로 빈 공간인 `@5001`에 저장한 다음 이 주소를 `@1001`에 넣어준다. 이로써 기본형 데이터에 대한 변수 선언 및 할당이 종료 된다.

2. 복사는 변수 영역의 빈 공간인 `@1002`를 확보하고 식별자를 `b`로 지정한다. 이제 식별자 `a`를 검색해 그 값을 찾아오게 되는데 `@1001`에 저장된 값인 `@5001`을, 확보해둔 `@1002`의 값으로 대입해준다.

3. 참조형 데이터는 변수 영역의 빈 공간인 `@1003`을 확보해 식별자를 `obj1`로 지정한다. 그리고 데이터 영역의 빈 공간인 `@5002`를 확보하고, 데이터 그룹이 담기 위한 별도의 변수 영역인 `@7103~@7104`을 확보해 그 주소를 저장한다. `@7103`에는 식별자 `c`를 `@7104`에는 식별자 `d`를 대입한 다음 `c`에 대입할 값 `10`을 데이터 영역에서 검색 하면 `@5001`에 이미 저장 돼 있으므로 이 주소를 `@7103`에 연결하고 문자열인 `ddd`는 데이터 영역의 빈 공간에 새로 만들어 `@7104`에 연결한다. 여기까지 참조형 데이터인 객체에 대한 변수 선언 및 할당 과정이다.

4. 마지막으로 `obj1`를 `obj2`에 복사하기 위해선 변수 영역의 빈 공간인 `@1004`를 확보하고 식별자를 `obj2`로 지정한다. 이제 식별자 `obj1`을 검색(`@1003`)해 그 값인 `@5002`를 `@1004`의 값에 대입한다.

<br>
<br>

#### # 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티 변경 시

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 된다는 점에서 동일하다. `@1001`과 `@1002`는 모두 값이 `@5001`이 됐고, `@1003`과 `@1004`는 값이 모두 `@5002`가 되었다. 이처럼 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후 동작에 큰 차이가 발생한다.

<br>

```
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

<br>

변수 복사 이후 `b = 15;`를 위해서는 데이터 영역에 아직 `15`가 없으므로 새로운 공간인 `@5004`에 저장하고, 그 주소를 든 채로 변수 영역에서 식별자가 `b`인 주소를 찾는다. 따라서 `@1002`의 값이 `@5004`가 된다.

`obj2.c = 20;`를 위해서는 새로운 공간인 `@5005`에 `20`을 저장하고, 그 주소를 든 채로 변수 영역에서 `obj2`를 찾고(`@1004`) 그 값인 `@5002`가 가리키는 변수 영역에서 다시 `c`를 찾아(`@7103`) 그 곳에 `@5005`를 대입하게 된다.


<br>

<img src="https://user-images.githubusercontent.com/67410919/124533531-71525000-de4d-11eb-8c72-bf44700447ca.png" width="70%">

<br>
<br>

#### # 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티 변경 시

기본형 데이터를 복사한 변수 `b`의 값 변경 시 `@1002`의 값이 달라진 반면, 참조형 데이터를 복사한 변수 `obj2`의 프로퍼티 값을 변경 했을 땐 `@1004`의 값은 달라지지 않았다. 즉 변수 `a`와 `b`는 서로 다른 주소를 바라보게 되었으나 변수 `obj1`과 `obj2`는 여전히 같은 객체를 바라보고 있는 상태이다. 이를 코드로 표현하면 다음과 같다.

```
a !== b
obj1 === obj2
```

<br>

위 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점이다. 대부분의 자바스크립트 책에서 '기본형은 값을 복사하고 참조형은 주소값을 복사한다'고 설명하지만 엄밀히 따지면 어떤 데이터 타입이든 변수에 할당하기 위해서는 주소값을 복사해야 하기 때문에 **자바스크립트의 모든 데이터 타입은 참조형 데이터**일 수 밖에 없다. 다만 기본형은 주소값을 복사하는 과정이 한 번만 이루어지고 참조형은 한 단계를 더 거치게 된다는 차이가 있을 뿐이다.

