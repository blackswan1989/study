<br>

출처: 코어자바스크립트

<br>

# 01. 데이터 타입

<br>
<br>

## 1. 데이터 타입의 종류

<br>

자바스크립트 데이터 타입에는 크게 두가지가 있는데 기본형(원시형: primitive type)과 참조형(reference type)이다. 기본형에는 number, string, boolean, null 등이 있고  ES6에서는 Symbol이 추가되었다. 

참조형으로는 객체(object)에 속하는 Array, function, Date, 정규표현식(RegExp) 등과, ES6에 추가된 Map, WeakMap, Set, WakSet 등이 객체의 하위 분류에 속한다.

<br>

<img src="https://user-images.githubusercontent.com/67410919/122848027-b782bc00-d343-11eb-9811-5548b276018f.png" width="50%">

<br>
<br>

기본형과 참조형을 구분하는 기준은 일반적으로 기본형은 할당이나 연산시 복제가 되고, 참조형은 참조가 된다고 알려져 있다. 엄밀히 말하면 둘 다 복제를 하긴 한다. 다만 기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다르다.

기본형은 불변성(immutability)을 띈다. 이 불면성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고 나아가 '식별자'와 '변수'의 개념을 구분할 수 있어야 한다. 메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 살펴보자.

<br>
<br>
<br>

## 2. 데이터 타입에 관한 배경 지식

<br>

### 2.1 메모리와 데이터

<br>

컴퓨터에서 0 또는 1 로만 표현할 수 있는 하나의 메모리 조각을 비트(bit)라고 한다. 메모리는 매우 많은 비트들로 구성되어 있는데, 각 비트는 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있다. 

비트 단위로 위치를 확인하는 것은 매우 비효율적이므로 몇 개씩 묶어 하나의 단위로 여긴다면 표현할 수 있는 값도 늘어나 동시에 검색 시간을 줄일 수도 있게 된다. 한편 많은 비트를 한 단위로 묶으면 낭비되는 비트가 생기기도 한다. 자주 사용하지 않을 데이터를  표현하기 위해 빈 공간을 남겨놓기 보다는, 문제가 되지 않을 적정한 공간을 묶는 편이 낫다.

그런 고민의 결과로 바이트(byte) 단위가 생겨났는데, 1바이트는 8개의 비트로 구성되어 있다. 1비트마다 0 또는 1의 두 가지 값을 표현할 수 있으므로 1바이트는 총 256(2의 8승)값을 표현할 수 있다. 2바이트는 16개의 비트이므로 65536(2의 16승)개의 값을 표현할 수 있다.

이러한 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다. 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있다.

<br>
<br>

### 2.2 식별자와 변수

<br>

식별자라고 해야 할 곳에 변수를, 변수라고 해야 할 곳에 식별자를 쓰는 식으로 변수와 식별자를 혼용하는 경우가 많다. 문맥에 따라 무엇을 말하고자 하는지 유추할 수 있기 때문인데, 둘의 차이를 모르면 혼란스러울 수 있다.

먼저 변수(variable)는 '변할 수 있는 수'로 수학 용어를 차용하여 숫자를 의미하는 '수'가 붙었을 뿐 값이 반듯이 숫자여야 하는것은 아니다. 영단어 variable은 원래 '변할 수 있다'라는 형용사이지만 컴퓨터 용어로 쓸 때에는 '변할 수 있는 무언가'라는 명사로 확장시켰다. 

여기서 '무언가'란 데이터를 뜻한다. 숫자도 데이터이고 문자열, 객체, 배열 모두 데이터이다. 식별자(identifier)는 어떤 데이터를 식별하는 데  사용하는 이름으로 즉 '변수명'이다.

<br>
<br>
<br>

## 3. 변수 선언과 데이터 할당

<br>

### 3.1 변수 선언

<br>

변수 선언의 동작 원리를 알아보자. 먼저 `var a;` 와 같은 기본적인 변수 선언식을 예로 들어 말로 풀어 쓰면 "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"가 된다. 

이렇게 보면 결국 변수란 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**이라고 할 수 있다. 이 공간에 숫자를 담았다가 문자열을 담는 등의 다양한 명령을 내릴 수 있다.

위에서 선언한 `var a;` 변수에 대한 메모리 영역의 변화를 살펴보면, 명령을 받은 컴퓨터는 메모리에 비어있는 공간 하나를 확보(`@1003` 주소값 확보)하고 이 공간의 이름(식별자)을 `a`라고 지정한다. 여기까지 변수의 선언 과정이다.

이후에 사용자가 `a`에 접근하고자 하면 컴퓨터는 메모리에서 `a`라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환하게 된다.

<br>
<br>

### 3.2 데이터 할당

<br>

```
var a;          // 변수 a 선언
a = 'abc';      // 변수 a에 데이터 할당

var a = 'abc';	// 변수 선언과 할당을 한 문장으로 표현
```

<br>

변수 할당 과정으로는 `a`라는 이름을 가진 주소를 검색해서 그곳에 문자열 `'abc'`를 할당한다고 해보자, 실제로는 메모리에서 `a`가 들어가있는 주소값의 위치에 문자열 `'abc'`를 직접 저장하지는 않는다.

<img `src="https://user-images.githubusercontent.com/67410919/123027127-46610880-d418-11eb-8ff3-677af63fb1a1.png" width="70%">

<br>
<br>

데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해 `'abc'`를 저장하고 그 주소를 변수 영역에 저장하는 식으로 이루어진다. 그리고 데이터의 성질에 따라 '변수 영역', '데이터 영역'으로 구분된다.

<br>

#### # 데이터 할당의 전체 흐름

1. 변수 영역에서 빈공간(`@1003`) 확보
2. 확보한 공간의 식별자를 `a`로 지정
3. 데이터 영역의 빈 공간(`@5004`)에 문자열 `'abc'` 저장
4. 앞서 저장한 문자열 주소(`@5004`)를 `@1003`의 공간에 대입
  
<br>

변수 영역에 값을 직접 대입하지 않고 한 단계를 더 거치는 이유는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위함이다. 

숫자형 데이터는 61비트의 공간을 확보하지만 문자열은 정해진 규격없이 한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이기 때문이다.

만약 미리 확보한 공간 내에서만 데이터 변환을 한다면 데이터를 다시 저장할 때 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 선행되어야 한다. 이런 경우 중간에 있던 데이터를 늘려야 한다면 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고 이동시킨 주소를 각 식별자에 다시 연결하는 작업이 필요해져 컴퓨터가 처리해야 할 연산이 많아질 수 밖에 없다. 

<img src="https://user-images.githubusercontent.com/67410919/123025614-d18ccf00-d415-11eb-8636-d50be68ac54e.png" width="70%">

<br>
<br>

결국 효율적으로 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이라고 할 수 있다. 문자열 `'abc'`의 마지막에 `'def'`를 추가하려고 하면 컴퓨터는 `'abc'`가 저장된 공간에 `'abcdef'`를 추가하는 대신 `'abcdef'`라는 문자열을 **새롭게** 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결시키는 방법으로 처리한다.

<br>
<br>
<br>

## 4. 기본형 데이터와 참조형 데이터

<br>

### 4.1 불변값

<br>

변수(variable)와 상수(constant)를 구분하는 성질은 '변경 가능성'인데 이 변경 가능성의 대상은 **변수 영역**의 메모리이다. 데이터 할당이 한 번 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다. 반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.

기본형 데이터인 숫자, 문자열, boolean, null 등은 모두 불변값이다. 예를 통해 개념을 알아보자

```
var a = 'abc';
a = a + 'def';
```

변수 `a`에 문자열 `'abc'`를 할당했다가 뒤에 `'edf'`를 추가하면 새로운 문자열 `'abcedf'`를 만들어 그 주소를 변수 `a`에 저장하게 된다. 즉 `'abc'`와 `'abcedf'`는 완전히 별개의 데이터이다.

<br>

```
var b = 5;
var c = 5;
b = 7
```

여기서도 변수 `'b'`에 숫자 5를 할당하면 컴퓨터는 일단 데이터 영역에서 5를 찾고 없으면 그 때 데이터 공간을 하나 만들어 저장하고 그 주소를 `'b'`에 저장한다. 

그리고 변수 `'c'`를 선언하며 다시 같은 수인 숫자 5를 할당하려고 하는데, 이 때 컴퓨터는 데이터 영역에서 5를 찾는다. 변수 `'b'`에서 이미 만들어 놓은 값이 있으므로 그 주소를 재활용한다. 

마지막 줄에서 변수 `'b'`의 값을 7로 바꾸고자 하는데, 이 때 기존에 저장된 숫자 5를 7로 바꾸는 것이 아닌 기존에 저장했던 7을 찾아서 있으면 재활용하고 없으면 새로 만들어 `'b'`에 저장하는 것이다. 결국 모두 다른 값으로 변경되지 않는다.

이처럼 문자열이나 숫자 등은 한 번 만든 값을 다른 값으로 변경할 수 없다. 변경은 새로 만드는 동작을 통해서만 이루어진다. 이러한 성질이 바로 불변값이다. 한 번 만들어진 값은 가비지 컬렉터(garbage collector)로 부터 수거되지 않는 한 영원히 변하지 않는다.

<br>
<br>

### 4.1 가변값

<br>

기본형 데이터는 모두 불변값이지만 참조형 데이터는 기본적으로 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다. 참조형 데이터를 변수에 할당하는 과정 부터 확인해보자.

<br>

```
var obj1 = {
	a: 1,
	b: 'bbb'
};
```

<br>

<img src="https://user-images.githubusercontent.com/67410919/123194746-f64e7880-d4e1-11eb-9239-91588193063c.png" width="70%">

<br>

- 컴퓨터는 변수 영역의 빈 공간인 `@1002`를 확보하고 그 주소의 이름을 `obj1`로 지정한다.
- 임의의 데이터 저장 공간인 `@5001`에 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(`@7103~?`)를 `@5001`에 저장한다.
- `@7103` 및 `@7104`에 각각 `a`와 `b`라는 프로퍼티 이름을 지정한다.
- 데이터 영역에서 숫자 1을 검색하여 결과가 없으면 임의로 `@5003`에 저장하고 이 주소를 `@7103`에 저장한다.
- 문자열 `'bbb'`역시 임의로 `@5004`에 저장하고 이 주소를 `@7104`에 저장한다.